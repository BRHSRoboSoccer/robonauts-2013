#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     MotorControllers, sensorNone)
#pragma config(Sensor, S2,     ,               sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     ,               sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "HTIRS2-driver.h"
#include "HTMC-driver.h"
#include "NXTMMX-lib.h"

#define back S1
#define IR_sensor S2
#define right S3
#define compass S4
#define MUX S4

#define ST  0
#define C   1
#define CC  2
#define BL  3
#define L   4
#define FL  5
#define F   6
#define FR  7
#define R   8
#define BR  9
#define B  10

#define nbound 30
#define rbound 20
#define lbound 80
#define fbound 150
#define bbound 35

#define power 100
                    //(  MUX1,  MUX2,     A,     B)
int const mov[11][4]={{     0,     0,     0,     0},  //ST
                      {    25,   -25,    25,   -25},  //C
                      {   -25,    25,   -25,    25},  //CC
                      {     0,     0, power, power},  //BL
                      {-power,-power, power, power},  //L
                      {-power,-power,     0,     0},  //FL
                      {-power,-power,-power,-power},  //F
                      {     0,     0,-power,-power},  //FR
                      { power, power,-power,-power},  //R
                      { power, power,     0,     0},  //BR
                      { power, power, power, power}}; //B

int calibration(int const direction)
{c
  int angle;
  int dir=C;
  while(dir!=ST)
  {
    dir=SensorValue[compass];
    angle=dir-direction;
    if(angle<0)
    {
      angle=360+angle;
    }

    if(angle>nbound/2&&angle<180)
    {
      dir=CC;
    }
    else if(angle<360-nbound/2&&angle>180)
    {
      dir=C;
    }
    else
    {
      dir=ST;
    }

    nxtDisplayBigTextLine(6, "Comp=%d", angle);

    if(dir!=ST)
    {
      MMX_Run_Unlimited(MUX,MMX_ADDRESS,MMX_Motor_1,MMX_Direction_Forward,mov[dir][0]);
      MMX_Run_Unlimited(MUX,MMX_ADDRESS,MMX_Motor_2,MMX_Direction_Forward,mov[dir][1]);
      motor[motorA]=mov[dir][2];
      motor[motorB]=mov[dir][3];
    }
  }
  return angle;
}

int calc(int val, int direction)
{
  int length=SensorValue[back];
  int width=SensorValue[right];
  int const go[9]={CC, B,BL, L, F, R,BR, B, C};

  if(val==0)
  {
    return B;
  }

  if(length>fbound&&val>=4&&val<=6)
  {
    if(width<=lbound)
    {
      return FL;
    }
    else if(width>=rbound)
    {
      return FR;
    }
    else
    {
      return F;
    }
  }
  if(length<bbound)
  {
    if(val>=7||val<=3)
    {
      return F;
    }
  }

  return go[val-1];
}

task main()
{
  int val=0;
  int dir=0;
  int angle;
  MMX_Init(MUX,MMX_ADDRESS,0);
  SensorType[back]=sensorSONAR;
  SensorType[IR_sensor]=sensorI2CCustom;
  SensorType[right]=sensorSONAR;
  SensorType[compass]=sensorI2CHiTechnicCompass;
  wait1Msec(250);
  int const direction=SensorValue[compass];
  HTIRS2setDSPMode(IR_sensor, DSP_1200);
  while(true)
  {
    nNxtExitClicks=2;

    angle=calibration(direction);
    val=HTIRS2readACDir(IR_sensor);
    dir=calc(val, direction);
    nxtDisplayBigTextLine(0, "Back=%d", SensorValue[back]);
    nxtDisplayBigTextLine(2, "Right=%d", SensorValue[right]);
    nxtDisplayBigTextLine(4, "Val=%d", val);
    nxtDisplayBigTextLine(6, "Comp=%d", angle);

    MMX_Run_Unlimited(MUX,MMX_ADDRESS,MMX_Motor_1,MMX_Direction_Forward,mov[dir][0]);
    MMX_Run_Unlimited(MUX,MMX_ADDRESS,MMX_Motor_2,MMX_Direction_Forward,mov[dir][1]);
    motor[motorA]=mov[dir][2];
    motor[motorB]=mov[dir][3];

    if(nNxtButtonPressed==kExitButton)
    {
      MMX_Stop(MUX,MMX_ADDRESS,MMX_Motor_Both,MMX_Next_Action_Float);
      motor[motorA]=0;
      motor[motorB]=0;
      break;
    }
  }
}
