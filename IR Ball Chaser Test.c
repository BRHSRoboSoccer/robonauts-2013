#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     MotorControllers, sensorI2CMuxController)
#pragma config(Sensor, S2,     TouchSensor,    sensorTouch)
#pragma config(Sensor, S3,     SMUX1,          sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX2,          sensorI2CCustom)
#pragma config(Motor,  motorB,          Kicker,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Dribbler,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorFL,       tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Sensor Setup:

S1: MotorControllers (TETRIX Motor Controllers)
S2: KickerTouch
S3: SMUX1 (HiTechnic Sensor Multiplexer)
		1 - IRBack (HiTechnic IRSeeker V2)
		2 - IRFront (HiTechnic IRSeeker V2)
		3 - USBack (Lego Ultrasonic Sensor)
		4 - USRight (Lego Ultrasonic Sensor)
S4: SMUX2 (MindSensors Port Splitter)
		1 - Colour (HiTechnic Color Sensor V2)
		2 - HaveBaller (Lego Touch Sensor)
		3	- Compass (HiTechnic Compass Sensor)
*/

#include "common.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"
#include "hitechnic-compass.h"
#include "hitechnic-colour-v2.h"
#include "lego-touch.h"

const tMUXSensor IRBack = msensor_S3_1;
const tMUXSensor IRFront = msensor_S3_2;
const tMUXSensor USBack = msensor_S3_3;
const tMUXSensor USRight = msensor_S3_4;
const tMUXSensor Colour = msensor_S4_1;
const tMUXSensor HaveBaller = msensor_S4_2;
const tMUXSensor Compass = msensor_S4_3;

#define ST  0
#define F   1
#define FR  2
#define R   3
#define BR  4
#define B   5
#define BL  6
#define L   7
#define FL  8
#define CW  9
#define CC  10

#define nbound 15
#define rbound 30
#define lbound 152
#define fbound 213
#define bbound 30
#define rgoalbound 61
#define lgoalbound 152
#define widthAdjust 25

#define whiteThreshold 200

#define power 15
#define turnPower 10

	long currentRed = 0;
  long currentGreen = 0;
  long currentBlue = 0;
	long gRed = 0;
  long gGreen = 0;
  long gBlue = 0;
  long wRed = 0;
  long wGreen = 0;
  long wBlue = 0;
  long bRed = 0;
  long bGreen = 0;
  long bBlue = 0;
  int _target = 0;

							//y	x		(   motorFL,   	motorFR,	  motorBR,	  motorBL)
int const mov[11][4]={{					0,			    0,     	 		0, 	        0},  //ST
                      {		 -power,			power,			power,		 -power},  //F
                      {		 -power,					0,			power,					0},  //FR
                      {		 -power,		 -power,			power,			power},  //R
                      {					0,		 -power,					0,			power},  //BR
                      {			power,		 -power,		 -power,			power},  //B
                      {			power,				  0,		 -power,					0},  //BL
                      {			power,			power,		 -power,		 -power},  //L
                      {					0,			power,					0,		- power},  //FL
                      {-turnPower, -turnPower, -turnPower, -turnPower},  //CW
                      {	turnPower,	turnPower,  turnPower,  turnPower}}; //CC

void hashtagyoloswagdiem(){
	nxtDisplayCenteredTextLine(1, "KICKING");
	wait10Msec(300);
	motor[Dribbler] = 0;
	if(SensorValue(TouchSensor) == 1){
		while(SensorValue(TouchSensor) == 1){    // While the Touch Sensor is inactive (hasn't been pressed):
	  	motor[Kicker] = 100;
	  }
	}
  while(SensorValue(TouchSensor) == 0){		// While the Touch Sensor is active (has been pressed):
  	motor[Kicker] = 100;
  }
  motor[Kicker] = 0;
  motor[Dribbler] = 100;
}

int calc(){
  int length = SensorValue[USBack];
  int width = SensorValue[USRight];
  bool haveBall = TSreadState(HaveBaller);
  int frontIRValue = HTIRS2readACDir(IRFront);
  int backIRValue = HTIRS2readACDir(IRBack);
  int currentRelCompass = HTMCreadRelativeHeading(Compass);
  HTCS2readRGB(Colour, currentRed, currentGreen, currentBlue);


	nxtDisplayTextLine(3, "Abs:   %4d", currentRelCompass);
	nxtDisplayTextLine(4, "Dir:   %4d", frontIRValue);

  if(currentRelCompass < -nbound){
  	return CC;
  }
  else if(currentRelCompass > nbound){
  	return CW;
  }

  else{
  	if(!haveBall){
  		if(IRFront != 0){
  			switch(frontIRValue){
					case 1:
						return B;
						break;
					case 2:
						return BL;
						break;
					case 3:
						return L;
						break;
					case 4:
						return FL;
						break;
					case 5:
						return F;
						break;
					case 6:
						return FR;
						break;
					case 7:
						return R;
						break;
					case 8:
						return BR;
						break;
					case 9:
						return B;
						break;
				}
			}
  		else{
				switch(backIRValue){
  				case 0:
  					return ST;
  					break;
  				case 1:
  					return BR;
  					break;
  				case 2:
  					return BR;
  					break;
  				case 3:
  					return B;
  					break;
  				case 4:
  					return BL;
  					break;
  				case 5:
  					return BL;
  					break;
  				case 6:
  					return BR;
  					break;
  				case 7:
  					return B;
  					break;
  				case 8:
  					return BL;
  					break;
  				case 9:
  					return BL;
  					break;
				}
			}
		}
		else{
			hashtagyoloswagdiem();
			return F;
		}
	}
}

void move(int dir){
	motor[motorFL]=mov[dir][0];
	motor[motorFR]=mov[dir][1];
	motor[motorBR]=mov[dir][2];
	motor[motorBL]=mov[dir][3];
}

void calibrate(){
	eraseDisplay();
  wait10Msec(20);
  while(nNxtButtonPressed != kEnterButton) {
		nxtDisplayCenteredTextLine(0, "Robonauts");
		nxtDisplayCenteredTextLine(1, "Offense");
		nxtDisplayCenteredBigTextLine(3, "Calibrate Compass");
		nxtDisplayTextLine(4, "Abs:   %4d", HTMCreadHeading(Compass));
		nxtDisplayCenteredTextLine(6, "Press Enter");
 	}
 	eraseDisplay();
 	nxtDisplayTextLine(2, "Setting");
  nxtDisplayTextLine(3, "target");
  wait1Msec(500);
  // Set the current heading as the value for the offset to be used as the
  // new zero-point for the relative heading returned by
  // HTMCreadRelativeHeading()
  _target = HTMCsetTarget(Compass);
  PlaySound(soundBlip);
  while(bSoundActive){
  	EndTimeSlice();
  }
  eraseDisplay();
  while(nNxtButtonPressed != kEnterButton) {
		nxtDisplayCenteredTextLine(0, "Robonauts");
		nxtDisplayCenteredTextLine(1, "Offense");
		nxtDisplayCenteredBigTextLine(3, "START ROBOT");
		nxtDisplayCenteredTextLine(6, "Press Enter");
 	}
 	eraseDisplay();
}


task main(){
	calibrate();
	motor[Dribbler] = 100;
	if(SensorValue(TouchSensor) == 0){
		while(SensorValue(TouchSensor) == 0){    // While the Touch Sensor is inactive (hasn't been pressed):
			motor[Kicker] = 100;
		}
		motor[Kicker] = 0;
	}
	while(true){
		move(calc());
	}
}
